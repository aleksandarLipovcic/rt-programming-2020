Unutar fajla, gdb-output.txt, nalazi log dibagovanja, koji je izvrsen nad datim zadatkom sigseg.c
Iako je unutar njega, relativno detaljno objasnjeno sta se desava, po koracima, ovo je jos jedan dokument koji pojasnjava prethodno izvrsavanje programa.
Unutar prve linije maina, vrsi se alociranje(malloc()) bloka memorije od 8B, na heapu, te funkcija preko registara RDI, sto je ulazni argument f-je, odnosno broj Bajtova za alokaciju, odnosno RAX, vraca adresu alociranog bloka. Ta vrijedsnost, se smjesta u promjenjivu p, sto je pokazivac na mem blok, na lokaciji koja je 0x8 unazad, u odnosu na adresu sadrzanu u Base pointeru.(To je lokacija p!) Kako je alokacija uspjesno izvrsena, u p imamo adresu mem bloka, nastavljamo dalje. Sljedeca linija, vrsi smjestanje vrijednosti 0x64=100d, u datu promjenjivu, sto bi znacilo da promjenjiva p, pokazuje na mem blok, sa pocetnom adresom 0x64. Na taj nacin smo izgubili prethodno alociran blok(Osim ako nismo mijenjali RAX registar, pa imamo srece da se u njemu jos uvijek nalazi povratna vrijednost f-je malloc), i pokusavamo da posmatramo mem blok, od adrese 0x64 na heapu. U ovom koraku, nema nikakvih gresaka, kompajler nece naravno nista prijaviti(osim warninga sa kastovanjem, zbog pokazivaca, pa misli da zelimo upisati vrijednost 100 na lokaciju, a ne da nam lokacija bude 100) iako vec mozemo naslutiti sta ce predstavljati problem.
Funkcija free(), vrsi dealokaciju alociranog mem bloka na heapu, te kao argument zahtijeva pocetnu adresu mem bloka. To se prosljedjuje preko RDI registra, te se vrsi poziv funkcije. Prilikom izvrsavanja f-je, imamo niz pushovanja registara(vrijednosti) na stek, prebacivanja izmedju registara i slicno, ali ono sto je krucijalno, je pokusaj pristupa toj mem lokaciji na heapu, kako bi se "oslobodila", sto ce rezultovati segmentation faultom. Na osnovu toga, zakljucujemo da je osnovni krivac, prethodna linija source koda, kojom smo umjesto upisivanja neke vrijednosti na zeljenu lokaciju, promjenili tu lokaciju, i izazvali SF, sa svakim pokusajem pristupa toj lokaciji. 
U skladu sa tim, tu liniju mozemo "izbaciti", ili mozemo dodati * ispred promjenjive p, i na taj nacin omoguciti pristup mem lokaciji, i upis vrijednosti 100, na tu lokaciju.
Pored toga, f-ja free, se izvrsava prije linije *p=110, sto je problematicno, iako u ovom slucaju nece biti nikakvih gresaka. Ono sto je problem, je to sto vrsimo dealokaciju mem bloka, a zatim na tu adresu vrsimo nekakav upis, iako ta adresa, vise ne pripada prethodnoj promjenjivoj. Na osnovu toga, da smo imali ispod free(), jos neko alociranje i dodjelu, skoro pa sigurno bi OS, dodjelijo mem blok, upravo od te adrese, sto bi sa linijom *p=110, izazvalo na neki nacin, neovlascen pristup. Kako bismo to izbjegli, korektno je vrsiti dealokaciju po zavrsetku koriscenja, te dodatno, postaviti pokaziv na NULL. Na taj nacin "gubimo" mogucnost pristupa adresi, koja vise ne pripada toj promjenjivoj.
